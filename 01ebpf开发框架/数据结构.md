# PerfEventArray
可以通过 `PerfEventArray` 向用户空间发送事件比如数据包/性能指标等等
高性能，高吞吐场景，可以每秒数十万事件
PerfEventArray 是较早期的 eBPF 映射类型，几乎所有支持 eBPF 的内核（3.18+）都支持。若使用 5.8+ 内核，也可考虑更高效的 RingBuf（BPF_MAP_TYPE_RINGBUF），但 PerfEventArray 兼容性更好

PerfEventArray是内核程序向用户态传递事件的机制，通过按cpu核数隔离的缓冲区实现高效数据传输
支持异步通知

内核态ebpf代码例子
```rust
// 定义发送到用户态的事件结构，必须实现copy
#[repr(C)]
#[derive(Debug, Copy, Clone)]
struct NetworkEvent {
    src_ip: u32,
    dest_ip: u32,
    packet_size: u32,
}
// 定义PerfEventArray映射
#[map(name="EVENTS")]
static mut EVENTS: PerfEventArray<NetworkEvent> = PerfEventArray::with_max_entries(1024,0);

fn try_event_tracing(ctx: XdpContext) -> Result<u32, ()> {
    // 解析 IPv4 头部（简化示例）
    let iphdr = ctx.ipv4hdr()?;
    
    // 构造事件数据
    let event = NetworkEvent {
        src_ip: iphdr.src_addr,
        dest_ip: iphdr.dst_addr,
        packet_size: ctx.len() as u32,
    };

    // 获取当前 CPU 核 ID（用于定位 PerfEventArray 中的缓冲区）
    let cpu_id = aya_bpf::helpers::bpf_get_smp_processor_id() as u32;

    // 发送事件到用户态（写入当前 CPU 对应的缓冲区）
    unsafe {
        EVENTS.output(&ctx, &event, 0, cpu_id);
    }
```

内核态与用户态的事件结构（NetworkEvent）必须完全一致（字段类型、顺序、大小），否则会出现解析错误。建议使用 #[repr(C)] 确保内存布局一致：
用户空间代码例子
```rust
// 必须与内核态定义的结构一致
#[derive(Debug)]
struct NetworkEvent {
    src_ip: u32,
    dest_ip: u32,
    packet_size: u32,
}
#[tokio::main]
fn main() {
    ...
     let mut bpf = Bpf::load_file("target/bpfel-unknown-none/debug/xdp-trace")?;
    
    // 获取 XDP 程序并附加到网络接口
    let mut xdp = Xdp::try_from(bpf.program_mut("event_tracing")?)?;
    xdp.attach("eth0", None)?;  // 替换为实际网络接口
    // 打开 PerfEventArray 映射
    let mut events = PerfEventArray::try_from(bpf.map_mut("EVENTS")?)?;

    // 为每个 CPU 核注册事件处理回调
    for cpu_id in 0..events.cpus()? {
        let mut buf = events.open(cpu_id, None)?;
        
        tokio::spawn(async move {
            loop {
                // 读取当前 CPU 核的事件缓冲区
                let events = buf.read_events()?;
                for event in events {
                    // 解析事件数据（与内核态结构对应）
                    let net_event = unsafe { &*(event.as_ptr() as *const NetworkEvent) };
                    
                    // 打印事件信息（转换 IP 地址为字符串）
                    println!(
                        "捕获包：源 IP: {:?}, 目的 IP: {:?}, 大小: {} bytes",
                        Ipv4Addr::from(net_event.src_ip),
                        Ipv4Addr::from(net_event.dest_ip),
                        net_event.packet_size
                    );
                }

}

```


# bpf_trace_printk
主要是调试用，性能差

# RingBuf
需要内核版本比较高
也是为高吞吐的内核态到用户态通信设计的，采用的是无锁环形缓冲区设计，性能更高
他是一个全局缓冲区，用户无需关心cpu核绑定，使用更简单
内核态代码

```rust
// 定义事件结构（需与用户态一致，用 #[repr(C)] 保证内存布局）
#[repr(C)]
#[derive(Debug)]
struct NetworkEvent {
    src_ip: u32,    // 源 IP（网络字节序）
    dest_ip: u32,   // 目的 IP（网络字节序）
    packet_size: u32,
}
// 定义 RingBuf 映射（键类型无用，值为事件结构）
#[map(name = "EVENTS_RINGBUF")]
static mut EVENTS: RingBuf<NetworkEvent> = RingBuf::with_max_entries(4096, 0);  // 缓冲区大小 4096 条目

fn try_ringbuf_demo(ctx: XdpContext) -> Result<u32, ()> {
    // 解析 IPv4 头部（简化示例）
    let iphdr = unsafe { &*(ctx.data()? + mem::size_of::<network_types::eth::EthHdr>()) as &Ipv4Hdr };

     // 分配 RingBuf 空间（内核自动管理内存）
    let mut event = unsafe {EVENTS.reserve::<NetworkEvent>() }.ok_or(())?;

    // 填充事件数据
    event.src_ip = iphdr.src_addr;
    event.dest_ip = iphdr.dst_addr;
    event.packet_size = ctx.len() as u32;

     // 提交事件（发送到用户态）
    event.submit();

}
```

用户态程序
用户态 next_event().await 会阻塞至有新事件，也可使用 try_next() 实现非阻塞轮询
```rust
use aya_ebpf::maps::RingBuf;


// 与内核态事件结构完全一致（内存布局必须相同）
#[repr(C)]
#[derive(Debug)]
struct NetworkEvent {
    src_ip: u32,
    dest_ip: u32,
    packet_size: u32,
}


#[tokio::main]
async fn main() -> Result<(), anyhow::Error> {
    // 加载 eBPF 程序
    let mut bpf = Bpf::load_file("target/bpfel-unknown-none/debug/ringbuf-demo")?;

    // 附加 XDP 程序到网络接口（如 eth0）
    let mut xdp = Xdp::try_from(bpf.program_mut("ringbuf_demo")?)?;
    xdp.attach("eth0", None)?;  // 替换为实际接口名
    
    // 打开 RingBuf 映射
    let mut ringbuf = RingBuf::try_from(bpf.map_mut("EVENTS_RINGBUF")?)?;

    // 启动事件循环，监听并处理内核发送的事件
    tokio::spawn(async move {
        loop {
            // 阻塞等待新事件（非阻塞方式：try_next()）
            let event = ringbuf.next_event().await?;
            let net_event = unsafe { &*(event.as_ptr() as *const NetworkEvent) };

            // 解析并打印事件（转换 IP 地址为字符串）
            println!(
                "接收事件: 源 IP={:?}, 目的 IP={:?}, 包大小={} bytes",
                Ipv4Addr::from(net_event.src_ip),
                Ipv4Addr::from(net_event.dest_ip),
                net_event.packet_size
            );
        }
        Ok::<_, aya::Error>(())
    });

    // 等待中断信号（保持程序运行）
    tokio::signal::ctrl_c().await?;
    Ok(())
```